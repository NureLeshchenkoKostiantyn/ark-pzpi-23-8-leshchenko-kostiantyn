Міністерство освіти і науки України 


Харківський національний університет радіоелектроніки 
Кафедра «Програмної інженерії»


ЛАБОРАТОРНА РОБОТА №2 
«РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)»








Виконав:                                                                                            Прийняв:
ст. гр. ПЗПІ-23-8                                                                              Дашенков Д.С.
Лещенко Костянтин Сергійович






Харків 2025
Мета роботи: Розробити базу даних для серверної частини програмної системи та прикладного програмного інтерфейсу (API).
Тема роботи: Програмна система для автоматизації контролю касових черг.
Посилання на відеозапис: https://youtu.be/7Z5O17Vzr58
Хід роботи
1.	Розробити будову програмної системи 1.1 Архітектурні рішення Програмна система для автоматизації контролю касових черг базується на трирівневій архітектурі, яка забезпечує чіткий розподіл функціональних обов'язків між клієнтськими інтерфейсами, сервером бізнес-логіки та сховищем даних.
1.1.1 Серверна частина (Back-end) Серверна частина є центральним компонентом системи, який обробляє запити від клієнтів та керує процесами моніторингу черг. Технологічний стек:
•	Python 3.10+;
•	фреймворк FastAPI;
•	REST API;
•	SQLAlchemy ORM;
•	SQLite (для прототипу);
•	JWT для автентифікації.
Ключові функції сервера: прийом даних від IoT-клієнтів, оновлення стану черг, розрахунок часу очікування, надсилання сповіщень.
1.1.2 Клієнтські взаємодії
•	Веб-клієнт менеджера (React): моніторинг та аналітика.
•	PWA-клієнт касира: отримання сповіщень.
•	IoT-клієнт: передача даних про кількість людей у черзі (OpenCV + YOLOv8).
1.1.3 База даних Використовується реляційна база даних SQLite для зберігання інформації про користувачів, каси та стан черг.
 

Рисунок 1.1 – Архітектура програмної системи
1.2 Опис моделей даних та зв'язків Для зберігання даних використовується реляційна модель. Основні сутності:
•	Users – користувачі системи;
•	Checkouts – каси закладу;
•	Queues – поточний стан черг на касах.
Зв’язки: Checkouts 1:N Queues (одна каса має одну чергу).
Моделі даних (фрагмент коду з models.py)
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from .database import Base

1.class User(Base):
2.    __tablename__ = "users"
3.
4.    id = Column(Integer, primary_key=True)
5.    email = Column(String, unique=True)
6.    role = Column(String)
7.
8.class Checkout(Base):
9.    __tablename__ = "checkouts"
10.
11.    id = Column(Integer, primary_key=True)
12.    name = Column(String)
13.    is_active = Column(Boolean, default=True)
14.
15.    queue = relationship("Queue", back_populates="checkout", uselist=False)
16.
17.class Queue(Base):
18.    __tablename__ = "queues"
19.
20.    id = Column(Integer, primary_key=True)
21.    checkout_id = Column(Integer, ForeignKey("checkouts.id"))
22.    people_count = Column(Integer)
23.    updated_at = Column(DateTime, default=datetime.utcnow)
24.
25.    checkout = relationship("Checkout", back_populates="queue")

2.	Створити UML діаграму прецедентів для серверної частини системи. 2.1 Актори Менеджер, Касир, IoT-клієнт. 2.2 Опис прецедентів Менеджер: авторизація, перегляд черг, управління касами. Касир: авторизація, отримання сповіщень. IoT-клієнт: оновлення кількості людей у черзі.
 
Рисунок 2.1 – UML-діаграма прецедентів серверної частини 


 

Рисунок 3.1 – ER-діаграма бази даних
4.	Розробити базу даних (БД) програмної системи. 4.1 Проєктування таблиць БД База даних створюється автоматично за допомогою SQLAlchemy. Фрагмент підключення (database.py):
1.Python
2.from sqlalchemy import create_engine
3.from sqlalchemy.orm import sessionmaker, declarative_base
4.
5.DATABASE_URL = "sqlite:///./queue.db"
6.
7.engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
8.SessionLocal = sessionmaker(bind=engine)
9.Base = declarative_base()
5.	Створити діаграму структури БД.

 
Рисунок 5.1 – Структура бази даних

Розробити функції роботи з БД (ORM). Використано SQLAlchemy ORM. Приклад CRUD-операції (фрагмент з main.py):
1.Python
2.def get_db():
3.    db = SessionLocal()
4.    try:
5.        yield db
6.    finally:
7.        db.close()
8.
9.@app.put("/queues/{queue_id}")
10.def update_queue(queue_id: int, data: schemas.QueueUpdate, db: Session = Depends(get_db)):
11.    queue = db.query(models.Queue).filter(models.Queue.id == queue_id).first()
12.    queue.people_count = data.people_count
13.    queue.updated_at = datetime.utcnow()
14.    db.commit()
15.    return {"message": "Чергу оновлено"}
7.	Розробити API для взаємодії серверної частини з клієнтами. Реалізовано REST API з використанням FastAPI. Фрагмент схем (schemas.py):
1.Python
2.class CheckoutCreate(BaseModel):
3.    name: str
4.
5.class QueueUpdate(BaseModel):
6.    people_count: int
7.
8.class NotificationCreate(BaseModel):
9.    message: str
8.	Створити специфікацію розробленого API. 8.1 Автентифікація POST /auth/login — повертає JWT-токен.

 
Рисунок 8.1 – Автентифікація через

8.2 Робота з касами POST /checkouts — створення каси. GET /checkouts — список кас.
 
 
Рисунок 8.2 – Створення та перегляд кас
8.3 Робота з чергами GET /queues — список черг. PUT /queues/{id} — оновлення кількості людей.
 
 
Рисунок 8.3 – Оновлення та перегляд стану черг

8.4 Сповіщення POST /notifications — надсилання сповіщення.
 
Рисунок 8.4 – Надсилання сповіщення

 
Рисунок 8.5 – Загальний вигляд Swagger UI

9–10. Перевірка роботи створеного програмного коду серверної частини системи. Серверна частина перевірена через вбудований інтерфейс Swagger UI та інструмент DB Browser for SQLite. Дані коректно зберігаються у файлі queue.db.
Висновки У результаті виконання лабораторної роботи №2 розроблено серверну частину програмної системи з базою даних SQLite та повноцінним REST API на базі FastAPI. Реалізовано автентифікацію JWT, операції з касами та чергами, механізм сповіщень. 
