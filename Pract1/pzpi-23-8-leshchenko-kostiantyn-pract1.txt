Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії



ЗВІТ
до практичного завдання
з дисципліни «Аналіз та рефакторинг коду»
на тему:
«Правила оформлення програмного коду в Rust»





 Виконав:                                                                 Перевірив:
 ст. гр. ПЗПІ-23-8                                                        ст. викладач кафедри ПІ
 Лещенко Костянтин                                                        Сокорчук Ігор Петрович 
                                                                                                               









Харків – 2025


ЗАВДАННЯ
1. Вступ: Важливість правил оформлення коду в контексті безпеки та надійності, які пропонує Rust.
2. Стиль коду та форматування: Використання автоматичного інструменту rustfmt.
3. Іменування: Дотримання конвенцій Rust (CamelCase, snake_case, SCREAMING_SNAKE_CASE).
4. Управління пам'яттю та безпека: Демонстрація правильного використання власності (ownership), запозичення (borrowing) та часу життя (lifetimes).
5. Обробка помилок: Використання типів Result<T, E> і Option<T> замість паніки та небезпечних блоків.
6. Структура проєкту та модулі: Організація коду за допомогою Cargo, mod, pub.
7. Тестування: Написання модульних та інтеграційних тестів.
8. Документування: Використання вбудованого інструменту rustdoc для створення документації.
9. Приклади оформлення коду: Аналіз поганого та хорошого коду.
10. Висновки: Узагальнення переваг дотримання правил Rust.








ОПИС ВИКОНАНОЇ РОБОТИ
1. Вступ: Філософія Rust — Безпека, Швидкість, Ергономіка
Rust — це мова програмування, яка робить акцент на безпеку, швидкість та паралелізм. Її унікальна система власності гарантує безпеку пам'яті та потокобезпеку без необхідності в збирачі сміття. Однак, ця потужність вимагає високої дисципіни від розробника. Правила оформлення коду в Rust не лише покращують читабельність, але й є прямим шляхом до написання стабільного, ефективного та безпечного програмного забезпечення. Дотримання цих правил допомагає запобігти типових помилок, таких как витоки пам'яті, змагання даних (data races), та інші невизначені поведінки, характерні для системних мов програмування.
2. Стиль коду та форматування з використанням rustfmt
На відміну від багатьох інших мов, де стиль кодування може бути предметом суперечок, в Rust існує офіційний інструмент для форматування — rustfmt. Його використання є стандартом де-факто.
Рекомендація: Завжди використовуйте rustfmt для автоматичного форматування коду. Це гарантує єдиний стиль у всьому проєкті.
Обґрунтування: Уніфікація форматування усуває непотрібні дискусії під час code review, дозволяючи зосередитись на логіці та архітектурі. rustfmt застосовує правила, визначені розробниками Rust, що робить код ідіоматичним.
Приклад:
1 // Погано: невідформатований код
2 fn main() { let x=5;
3 println!("{}",x);
4 }

1 // Добре: код, відформатований за допомогою `rustfmt`
2 fn main() {
3    let x = 5;
4  println!("{}", x);
5 }
Пояснення: rustfmt автоматично додає пробіли навколо операторів, переносить дужки та забезпечує правильні відступи (4 пробіли).
3. Іменування
Rust має чіткі конвенції щодо іменування, які дозволяють з першого погляду зрозуміти тип сутності.
Рекомендація: Дотримуйтесь стандартних конвенцій Rust:
• Типи, трейти: CamelCase (наприклад, MyStruct, HttpClient)
• Змінні, функції, модулі: snake_case (наприклад, user_name, calculate_area)
• Константи, статичні змінні: SCREAMING_SNAKE_CASE (наприклад, MAX_BUFFER_SIZE)
Обґрунтування: Послідовне іменування покращує читабельність та полегшує орієнтування в коді, особливо в великих проєктах або при використанні сторонніх бібліотек.
Приклад:
1 // Погано
2 const maxvalue: i32 = 100;
3 struct userdata {
4    name: String,
5 }
6 fn GetUserInfo() -> userdata {
7   // ...
8 }

1 // Добре
2 const MAX_VALUE: i32 = 100;
3 struct UserData {
4   name: String,
5 }
6 fn get_user_info() -> UserData {
7    // ...
8 }
4. Управління пам'яттю та безпека
Це ядро мови Rust. Правильне використання власності, запозичення та часів життя є критично важливим.
Рекомендація: Віддавайте перевагу запозиченню (&), аніж переміщенню, де це можливо. Чітко позначайте часи життя, коли це необхідно.
Обґрунтування: Це запобігає таким помилкам, як "використання після переміщення" (use-after-move) та забезпечує відсутність змагань даних.
Приклад:
1 // Погано: непотрібне переміщення даних
2 fn take_ownership(s: String) {
3    println!("{}", s);
4 }
5 fn main() {
6 let my_string = String::from("Hello");
7  take_ownership(my_string); // `my_string` переміщується і більше не 8доступна тут
9  // println!("{}", my_string); // Це призведе до помилки компіляції
10 }

1 // Добре: використання запозичення
2 fn borrow_string(s: &String) {
3  println!("{}", s);
4 }
5 fn main() {
6    let my_string = String::from("Hello");
7   borrow_string(&my_string); // `my_string` запозичується
8   println!("{}", my_string); // Все ще доступна
9 }
5. Обробка помилок
Rust активно заохочує використовувати типи Result<T, E> і Option<T> замість викидання винятків (exceptions).
Рекомендація: Завжди явно обробляйте помилки за допомогою match або операторів ?. Уникайте використання panic!, крім випадків, що відновленню не підлягають.
Обґрунтування: Це робить потоки помилок частиною системи типів, змушуючи розробника свідомо їх обробляти. Це запобігає неочікуваним падінням програми.
Приклад:
1 // Погано: використання `panic!` для звичайних помилок
2 fn divide(a: f64, b: f64) -> f64 {
3    if b == 0.0 {
4      panic!("Ділення на нуль!");
5   }
6   a / b
7 }

1 // Добре: використання `Result`
2 fn divide(a: f64, b: f64) -> Result<f64, String> {
3    if b == 0.0 {
4        return Err("Ділення на нуль!".to_string());
5    }
6    Ok(a / b)
7 }

1 // Виклик функції з явною обробкою помилки
2 fn main() {
3    match divide(10.0, 0.0) {
4        Ok(result) => println!("Результат: {}", result),
5        Err(e) => println!("Сталася помилка: {}", e),
6    }
7 }
6. Структура проєкту та модулі
Rust надає потужну систему модулів для організації коду. Менеджер пакетів Cargo є стандартом для управління залежностями та збіркою.
Рекомендація: Використовуйте cargo new для створення нового проєкту. Організовуйте код у модулі за допомогою ключових слів mod та pub. Використовуйте файли src/lib.rs для бібліотек та src/main.rs для виконуваних файлів.
Обґрунтування: Чітка структура модулів робить код легшим для навігації, тестування та повторного використання.
Приклад структури проєкту:
my_project/
├── Cargo.toml
└── src/
    ├── main.rs
    ├── lib.rs
    └── models/
        └── user.rs
Приклад оголошення модулів:
1 // src/models/user.rs
2 pub struct User {
3    pub name: String,
4 }
5 impl User {
6    pub fn new(name: String) -> Self {
7       User { name }
8    }
9 }

1 // src/lib.rs
2 pub mod models; // Експортує модуль `models`

1 // src/main.rs
2 use my_project::models::user; // Імпорт структури `User`
7. Тестування
Rust має вбудовану підтримку написання тестів, що робить його ідеальним для TDD.
Рекомендація: Пишіть модульні тести в тому ж файлі, що й код, який вони тестують, за допомогою атрибута #[cfg(test)]. Для інтеграційних тестів використовуйте директорію tests/.
Обґрунтування: Вбудована підтримка тестування сприяє написанню надійного коду та полегшує рефакторинг.
Приклад:
1 // src/lib.rs
2 pub fn add(a: i32, b: i32) -> i32 {
3    a + b
4 }
5
6 #[cfg(test)]
7 mod tests {
8   use super::*;
9
10    #[test]
11   fn it_adds_two() {
 12      assert_eq!(add(2, 2), 4);
13    }
14 }
8. Документування за допомогою rustdoc
Rust дозволяє писати документацію прямо в коді, використовуючи спеціальні коментарі /// для документування елементів та //! для документування модуля або крейта.
Рекомендація: Документуйте всі публічні API. Використовуйте Markdown у коментарях документації. Запускайте cargo doc для генерації красивої HTML-документації.
Обґрунтування: Добре документований код легший для використання іншими розробниками. rustdoc автоматично зв'язує типи та функції у документації.
Приклад:
1 /// Обчислює площу прямокутника.
2 ///
3 /// # Аргументи
4 /// * `width` - Ширина прямокутника.
5 /// * `height` - Висота прямокутника.
6 ///
7 /// # Повертає
8 /// Площу прямокутника типу `f64`.
9 ///
10 /// # Приклад
11 /// ```
12 /// let area = calculate_rectangle_area(5.0, 10.0);
13 /// assert_eq!(area, 50.0);
14 /// ```
15 pub fn calculate_rectangle_area(width: f64, height: f64) -> f64 {
 16   width * height
17 }

ВИСНОВКИ
Дотримання правил оформлення коду в Rust — це не просто сліпе слідування стилю. Це невід'ємна частина розробки, що безпосередньо впливає на якість, безпеку та підтримуваність програмного забезпечення. Використання інструментів, таких як rustfmt, clippy (лант для пошуку поширених помилок та антипатернів) та cargo, робить процес написання ідіоматичного коду набагато простішим. Основним висновком є те, що в Rust компілятор є вашим головним помічником, який наполегливо направляє вас до написання правильного та ефективного коду, а дотримання конвенцій дозволяє максимально використати цю перевагу.







ВИКОРИСТАНІ ДЖЕРЕЛА
1. The Rust Programming Language Book (The Book). URL: https://doc.rust-lang.org/book/ (дата звернення: 28.10.2025).
2. Rust Style Guide. URL: https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md (дата звернення: 28.10.2025).
3. Rust API Guidelines. URL: https://rust-lang.github.io/api-guidelines/ (дата звернення: 28.10.2025).
4. Офіційна документація rustfmt. URL: https://github.com/rust-lang/rustfmt (дата звернення: 28.10.2025).
5. Офіційна документація clippy. URL: https://github.com/rust-lang/rust-clippy (дата звернення: 28.10.2025).

ДОДАТОК А: ВІДЕОЗАПИС ДОПОВІДІ
Посилання на відеозапис: (https://youtu.be/FbIYAtfy7KY)
Хронологічний опис:
 00:00 - 01:04 - Вступ. Філософія Rust.
 01:04 - 02:00 - Стиль коду та rustfmt.
 02:00 - 02:41 - Іменування.
 02:41 - 03:28 - Властність та запозичення.
 03:28 - 04:07 - Обробка помилок.
 04:07 - 04:46 - Структура проєкту.
 04:46- 05:54 - Тестування.
 05:54 - 06:24 - Правильна обробка помилок.
 06:24 - 07:23 - Ключові переваги.
 07:23 - 07:45- висновки.


ДОДАТОК Б
Слайди презентації
Рисунок Б.1 — Титульна сторінка
Рисунок Б.2 — Вступ: Філософія Rust
Рисунок Б.3 — Стиль коду - rustfmt
Рисунок Б.4 — Іменування - конвенції Rust
Рисунок Б.5 — Власність та запозичення
Рисунок Б.6 — Обробка помилок
Рисунок Б.7 — Структура проєкту
Рисунок Б.8 — Тестування в Rust
Рисунок Б.10 — Використання Result у практиці
Рисунок Б.11 — Практичний приклад рефакторингу
Рисунок Б.12 — Ключові переваги
Рисунок Б.13 — Висновки та джерела






