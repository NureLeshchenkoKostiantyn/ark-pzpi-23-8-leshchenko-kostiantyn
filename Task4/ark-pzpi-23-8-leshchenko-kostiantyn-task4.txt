Міністерство освіти і науки України 


Харківський національний університет радіоелектроніки 
Кафедра «Програмної інженерії»


ЛАБОРАТОРНА РОБОТА №4 
«РОЗРОБКА IoT КЛІЄНТА (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ»








Виконав:                                                                                            Прийняв:
ст. гр. ПЗПІ-23-8                                                                              Дашенков Д.С.
Лещенко Костянтин Сергійович






Харків 2025
Мета роботи: Отримати практичні навички з розробки IoT клієнта, включаючи проектування його архітектури, бізнес-логіки, налаштувань, та інтеграцію із серверною частиною. Навчитися використовувати UML для створення діаграм прецедентів та діяльності, а також перевіряти функціональність IoT клієнта через тестування та інтеграцію.
Тема роботи: Програмна система для автоматизації контролю касових черг.
Посилання на відеозапис: https://youtu.be/kNPbvsI1vuI
Хід роботи
1.	Розробити будову програмного забезпечення IoT клієнта IoT клієнт реалізований як окремий Python-скрипт, що симулює роботу вбудованого пристрою (наприклад, Raspberry Pi з камерою). Архітектура клієнта включає:
•	Модуль симуляції підрахунку людей у черзі (замість реального комп'ютерного зору YOLOv8).
•	Бізнес-логіку (локальна перевірка порогу та генерація сповіщень).
•	Функції налаштування (завантаження параметрів з файлу config.json).
•	Модуль комунікації з сервером через HTTP (requests.put до ендпоінта /queues/{id}).
IoT клієнт працює в нескінченному циклі з інтервалом, визначеним у налаштуваннях, і забезпечує взаємодію з серверною частиною (FastAPI), розробленою в попередніх лабораторних роботах.
Фрагмент програмного коду будови IoT клієнта (iot_client.py, з нумерацією рядків):
Python
1 import requests  
2 import time  
3 import json  
4   
5 # Завантаження налаштувань  
6 with open("config.json", "r", encoding="utf-8") as f:  
7     config = json.load(f)  
8   
9 SERVER_URL = config["server_url"]  
10 CHECKOUT_ID = config["checkout_id"]  
11 ALERT_THRESHOLD = config["alert_threshold"]  
12 SIMULATED_PEOPLE = config["simulated_people"]  
13 INTERVAL = config["interval_seconds"]  
14   
15 def simulate_people_count():  
16     return SIMULATED_PEOPLE  
17   
18 def send_to_server(people_count):  
19     url = f"{SERVER_URL}/queues/{CHECKOUT_ID}"  
20     data = {"people_count": people_count}  
21     try:  
22         response = requests.put(url, json=data)  
23         return response.json()  
24     except Exception as e:  
25         return {"error": str(e)}  
26   
27 while True:  
28     people = simulate_people_count()  
29     print(f"Виявлено {people} людей у черзі")  
30     if people > ALERT_THRESHOLD:  
31         print("ЛОКАЛЬНЕ СПОСТЕРЕЖЕННЯ: Черга переповнена!")  
32     result = send_to_server(people)  
33     print("Відповідь сервера:", result)  
34     time.sleep(INTERVAL)

 
Рисунок 1.1 – UML-діаграма прецедентів IoT клієнта

 
Рисунок 2.1 – UML-діаграма діяльності IoT клієнта

2.	Розробити бізнес-логіку та функції налаштування IoT клієнта Бізнес-логіка реалізована локально на клієнті: перевірка кількості людей відносно порогу (ALERT_THRESHOLD) та вивід сповіщення перед відправкою на сервер. Це зменшує навантаження на мережу та сервер.
Функції налаштування: всі параметри (URL сервера, ID каси, поріг, симульована кількість людей, інтервал) винесено в файл config.json для легкої зміни без перекомпіляції коду.

 
Рисунок 3.1 – Файл налаштувань config.json

 
Рисунок 3.2 – Запуск IoT клієнта та вивід у консоль

 
Рисунок 3.3 – Оновлення даних у сервері після відправки з IoT клієнта

 
 
Рисунок 3.4 – Перевірка роботи при зміні налаштувань
3–6. Програмна реалізація, перевірка роботи IoT клієнта Реалізація виконана як окремий скрипт iot_client.py з запуском через run_iot.bat. Перевірка проведена: IoT клієнт успішно відправляє дані на сервер, оновлює чергу в БД, виконує локальну бізнес-логіку. Зміна налаштувань в config.json впливає на поведінку без перезапуску сервера.
Висновки У результаті лабораторної роботи №4 розроблено IoT клієнт для симуляції моніторингу черг. Реалізовано бізнес-логіку (локальне сповіщення при перевищенні порогу) та функції налаштування (через config.json). Клієнт успішно інтегровано з серверною частиною через HTTP-запити. 

