Міністерство освіти і науки України 


Харківський національний університет радіоелектроніки 
Кафедра «Програмної інженерії»


ЗВІТ 
до практичного завдання № 2
	з дисципліни «Аналіз та рефакторинг коду» на тему	
на тему: «Методи рефакторингу коду програмного забезпечення»






Виконав:                                                                             Прийняв:
ст. гр. ПЗПІ-23-8                                                               ст. викладач кафедри ПІ 
Лещенко Костянтин Сергійович                                     Сокорчук Ігор Петрович






Харків 2025

ЗАВДАННЯ
Обрати три методи рефакторингу з книги М. Фаулера «Refactoring. Improving the Design of Existing Code» (1999):
1.	Remove Control Flag (с. 161)
2.	Substitute Algorithm (с. 139)
3.	Change Reference to Value (с. 122)
Мова програмування — Rust. Для кожного методу: опис проблеми, код до рефакторингу, код після, пояснення переваг. 

ОПИС ВИКОНАНОЇ РОБОТИ
Рефакторинг — контрольоване покращення дизайну коду без зміни його функціональності (М. Фаулер). У Rust це особливо ефективно завдяки ownership, borrow checker та потужним ітераторам, які дозволяють писати безпечний та виразний код.
Метод 1: Remove Control Flag Проблема: Змінна-прапорець (наприклад, found: bool) використовується для контролю виходу з циклу. Це призводить до зайвої мутабельності, ускладнює розуміння потоку, порушує принцип "раннього виходу" (early return/break). У Rust це часто суперечить ідіоматичному використанню ітераторів. Застосування: Заміна присвоєння прапорцю на break, return або метод any()/find(). Переваги: Код стає коротшим, зрозумілішим, з меншою кількістю змінних. Покращується читабельність, легше тестувати, краще відповідає стилю Rust (zero-cost abstractions через ітератори).
Метод 2: Substitute Algorithm Проблема: Ручна реалізація алгоритму (наприклад, пошук мінімуму через цикл) — надмірно детальна, схильна до помилок (обробка порожнього вектора, off-by-one), дублює функціональність стандартної бібліотеки. Застосування: Повна заміна тіла функції на вбудовані методи (iter().min(), iter().find() тощо). Переваги: Значне скорочення коду, використання перевіреного та оптимізованого коду std::, автоматична обробка крайніх випадків, краща продуктивність та підтримуваність. У Rust ітератори — це ефективні абстракції без накладних витрат.
Метод 3: Change Reference to Value Проблема: Невелика структура (наприклад, з координатами) передається/зберігається як посилання (& або Box), але повинна порівнюватися за значенням. Без відповідних trait'ів (PartialEq, Eq, Copy) порівняння == працює за адресою, виникають зайві borrow-проблеми та мутабельний стан. Застосування: Додавання #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)], використання за значенням. Переваги: Правильне семантичне порівняння, усунення мутабельного спільного стану, дешевше копіювання (Copy — на стеку), краще відповідає value-oriented дизайну в Rust для простих типів.
Приклади коду — у Додатку В. Візуальні diff'и змін — у презентації (Додаток Б).


ВИСНОВКИ
Розглянуто та застосовано три методи рефакторингу: Remove Control Flag, Substitute Algorithm, Change Reference to Value. Отримано навички виявлення типових code smells у Rust-коді та їх усунення. Результати:
•	зменшення обсягу коду на 30–60% у розглянутих фрагментах;
•	суттєве покращення читабельності та зрозумілості;
•	перехід до ідіоматичного Rust (ітератори, value semantics);
•	зменшення потенційних помилок (крайні випадки, неправильне порівняння);
•	полегшення подальшої підтримки та масштабування. Рефакторинг — ключовий інструмент для підтримки високої якості коду протягом усього життєвого циклу проєкту.









ВИКОРИСТАНІ ДЖЕРЕЛА (ДСТУ 8302:2015)
1.	Fowler M. Refactoring. Improving the Design of Existing Code. — Addison-Wesley Professional, 1999. — 464 с.
2.	The Rust Programming Language / Steve Klabnik, Carol Nichols. — Доступно за: https://doc.rust-lang.org/book/.
3.	Refactoring.Guru. Remove Control Flag. — https://refactoring.guru/remove-control-flag.
4.	Rust Standard Library Documentation: Iterators. — https://doc.rust-lang.org/std/iter/.


















ДОДАТОК А Відеозапис доповіді: https://youtu.be/vnTgesWwlJo























ДОДАТОК Б Слайди презентації 

 

 

 

 

 

 
 
 
 
 
 
 
 
 






ДОДАТОК В Програмний код
В.1 Приклад оформлення програмного коду GitHub репозиторій: 
1  fn main() {
2      println!("Приклад рефакторингу в Rust");
3  }
В.2 Код до рефакторингу (Remove Control Flag) GitHub: 
1  fn contains_target(items: &[i32], target: i32) -> bool {
2      let mut found = false;
3      for &item in items {
4          if item == target {
5              found = true;
6          }
7      }
8      found
9  }

В.3 Код після рефакторингу (Remove Control Flag)
text
1  fn contains_target(items: &[i32], target: i32) -> bool {
2      items.iter().any(|&item| item == target)
3  }

В.4 Код до рефакторингу (Substitute Algorithm)
1  fn find_minimum(vec: &[i32]) -> Option<i32> {
2      if vec.is_empty() {
3          return None;
4      }
5      let mut min = vec[0];
6      for &val in &vec[1..] {
7          if val < min {
8              min = val;
9          }
10     }
11     Some(min)
12 }

В.5 Код після рефакторингу
1  fn find_minimum(vec: &[i32]) -> Option<i32> {
2      vec.iter().copied().min()
3  }

В.6 Код до рефакторингу (Change Reference to Value)
1  #[derive(Debug)]
2  struct Point {
3      x: f64,
4      y: f64,
5  }
6  
7  // Порівняння p1 == p2 не працює коректно (за посиланням)

В.7 Код після рефакторингу
1  #[derive(Debug, Clone, Copy, PartialEq)]
2  struct Point {
3      x: f64,
4      y: f64,
5  }
6  
7  // Тепер p1 == p2 → true, якщо координати однакові

